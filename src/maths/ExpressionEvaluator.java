package maths;

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

public class ExpressionEvaluator {
	private String infix;	//given arithmetic expression
	private StringBuilder postfix;	//the postfix expression created
	private Stack<String> tokens;
	private final Set<String> OPS_FUNCS=new HashSet<>();
	private final Set<Character> BRACKETS = new HashSet<>();
	private final Set<Character> OPERATORS = new HashSet<>();

	public ExpressionEvaluator() {
		//operators
		OPS_FUNCS.add("+");
		OPS_FUNCS.add("-");
		OPS_FUNCS.add("*");
		OPS_FUNCS.add("/");
		OPS_FUNCS.add("^");
		OPS_FUNCS.add("%");
		OPS_FUNCS.add("!");

		//functions
		OPS_FUNCS.add("log");
		OPS_FUNCS.add("ln");
		OPS_FUNCS.add("sin");
		OPS_FUNCS.add("tan");
		OPS_FUNCS.add("cos");
		OPS_FUNCS.add("asin");
		OPS_FUNCS.add("acos");
		OPS_FUNCS.add("atan");
		
		//brackets
		BRACKETS.add('(');
		BRACKETS.add('[');
		BRACKETS.add('{');
		
		//only operators
		OPERATORS.add('+');
		OPERATORS.add('-');
		OPERATORS.add('*');
		OPERATORS.add('/');
		OPERATORS.add('^');
		OPERATORS.add('%');
		OPERATORS.add('!');
		
	}

	public String getInfix() {
		return infix;
	}
	public void setInfix(String infix) {
		this.infix = infix;
	}

	public static Double evaluate(String infix) {
		
		ExpressionEvaluator expr = new ExpressionEvaluator();
		
		expr.infix = expr.houseKeeping(infix.trim());
		
		//creating the postfix expression
		expr.createPostfix();
		
		//evaluating postfix
		return expr.evaluatePostfix();
	}
	
	//padding spaces between tokens
	//replacing constants with their values
	private String houseKeeping(String str) {
		str=trim(str);
		
		//padding with spaces
		StringBuilder pad=new StringBuilder();
		StringBuilder temp=new StringBuilder();
		int idx = 0;
		
		for(char c:str.toCharArray()){
			
			if(c=='-'){
				if(str.indexOf(c)==0)
					pad.append('-');
				else if(idx>0 && BRACKETS.contains(str.charAt(idx-1))) {
					pad.append('-');
				}
				else if(idx>0 && OPERATORS.contains(str.charAt(idx-1))) {
					pad.append('-');
				}
				else
					pad.append(" "+c+" ");
			}
			else if(c=='~'){
				pad.append('-');
			}
			else if(c>='0' && c<='9' || c=='.'){
				pad.append(c);
			}
			else if(c=='l'||c=='n'||c=='o'
					||c=='g'||c=='s'||c=='i'
					||c=='n'||c=='c'||c=='s'
					||c=='t'||c=='a'||c=='p'){
				temp.append(c);
				if(temp.toString().equals("log")||temp.toString().equals("ln")
						||temp.toString().equals("sin")
						||temp.toString().equals("cos")
						||temp.toString().equals("tan")
						||temp.toString().equals("asin")
						||temp.toString().equals("acos")
						||temp.toString().equals("atan")
						||temp.toString().equals("pi")){
					pad.append(temp+" ");
					temp=new StringBuilder();
				}
				
			}
			else
				pad.append(" "+c+" ");
			idx++;	//each character index
		}
		
		str=pad.toString().replaceAll("[ ]+", " ");	//remove extra spaces
		
		//replace costants
		str=str.replaceAll("e", Math.E+"").replaceAll("pi", +Math.PI+"");
		return str;
	}
	
	/**
	 * Removes all spaces between any operators and operands;
	 * the housekeeping function will take care of the appropriate 
	 * space padding afterwards
	 * @param str
	 * @return all space removed String from parameter str
	 */
	private String trim(String str) {
		StringBuilder stb = new StringBuilder();
		for(char c:str.toCharArray()) {
			if(c!=' ' && c!='\t' && c!='\n')
				stb.append(c);
		}
		return stb.toString();
	}

	/**
	 * This method returns the evaluated value of the 
	 * postfix expression generated by createPostfix()
	 * method.
	 * @return evaluated value of the (postfix) expression
	 * 
	 */
	private Double evaluatePostfix() {
		tokens= new Stack<>();
		if(postfix==null){
			return null;
		}
		for(String token:postfix.toString().trim().split(" ")) {

			if(isNumeric(token)){
				tokens.push(token);
			}
			
			else if(isBinaryOperator(token)){

				Double valA = Double.parseDouble(tokens.pop());
				Double valB = Double.parseDouble(tokens.pop());
				if(token.equals("+")){
					Double valC = valB + valA;
					tokens.push(valC.toString());
				}
				else if(token.equals("-")){
					Double valC = valB - valA;
					tokens.push(valC.toString());
				}
				else if(token.equals("*")){
					Double valC = valB * valA;
					tokens.push(valC.toString());
				}
				else if(token.equals("/")){
					Double valC = valB / valA;
					tokens.push(valC.toString());
				}
				else if(token.equals("^")) {
					Double valC = Math.pow(valB, valA);
					tokens.push(valC.toString());
				}
			}	
			else if(isUnaryOperator(token)){
				Double val = Double.parseDouble(tokens.pop());
				if(token.equals("!")){
					Integer res = factorial(val.intValue());
					tokens.push(res.toString());
				}
				else if(token.equals("%")) {
					tokens.push((val/100)+"");
				}
			}
			else if(isFunction(token)){
				Double val = Double.parseDouble(tokens.pop());
				if(token.equalsIgnoreCase("log")){					
					tokens.push(Math.log10(val)+"");
				}
				else if(token.equalsIgnoreCase("ln")){					
					tokens.push(Math.log(val)+"");
				}
				else if(token.equalsIgnoreCase("sin")){					
					tokens.push(Math.sin(val)+"");
				}
				else if(token.equalsIgnoreCase("cos")){					
					tokens.push(Math.cos(val)+"");
				}
				else if(token.equalsIgnoreCase("tan")){					
					tokens.push(Math.tan(val)+"");
				}
				else if(token.equalsIgnoreCase("atan")){					
					tokens.push(Math.atan(val)+"");
				}
				else if(token.equalsIgnoreCase("asin")){					
					tokens.push(Math.asin(val)+"");
				}
				else if(token.equalsIgnoreCase("acos")){					
					tokens.push(Math.acos(val)+"");
				}
			}
		}
		return Double.parseDouble(tokens.pop());
	}
	
	//factorial of an integer
	private Integer factorial(Integer v) {
		if(v<0)
			return null;
		if(v==1 || v==0)
			return 1;
		return v*factorial(v-1);
	}
	
	//returns true if the given arg is a binary operator
	private boolean isBinaryOperator(String op) {
		if(OPS_FUNCS.contains(op.trim())){
			if(op.equals("+")||op.equals("-")||op.equals("*")||
					op.equals("/")||op.equals("^")){
				return true;
			}
		}
		return false;
	}
	
	//returns true if the given arg is a unary operator
	private boolean isUnaryOperator(String op) {
		if(OPS_FUNCS.contains(op.trim())){
			if(op.equals("!")||op.equals("%")){
				return true;
			}
		}
		return false;
	}
	
	//return true if the given arg is a function
	private boolean isFunction(String op) {
		if(OPS_FUNCS.contains(op.trim())){
			if(op.equalsIgnoreCase("log")||
					op.equalsIgnoreCase("sin")||
					op.equalsIgnoreCase("tan")||
					op.equalsIgnoreCase("cos")||
					op.equalsIgnoreCase("asin")||
					op.equalsIgnoreCase("acos")||
					op.equalsIgnoreCase("atan")||
					op.equalsIgnoreCase("ln")){
				return true;
			}
		}
		return false;
	}

	/*
	 * This method creates postfix from given infix expression
	 */
	private void createPostfix(){
		this.tokens = new Stack<>();
		postfix = new StringBuilder();
		for(String token : this.infix.split(" ")) {
			if(isNumeric(token)){
				postfix.append(token+" ");
			}
			if(token.equals("(")){
				tokens.push(token);
			}
			if(token.equals(")")){
				String tk;
				while(!tokens.isEmpty() && !(tk=tokens.pop()).equals("(")){
					postfix.append(tk + " ");
				}

			}
			if(OPS_FUNCS.contains(token.trim().toLowerCase())){
				if(tokens.isEmpty()||tokens.peek().equals("("))
					tokens.push(token);
				else{
					while(!tokens.isEmpty() &&
							!tokens.peek().equals("(") &&
							precedence(token)<=precedence(tokens.peek())){
						postfix.append(tokens.pop()+" ");
					}
					tokens.push(token);
				}
			}
		}
		while(!tokens.isEmpty()){
			postfix.append(tokens.pop()+" ");
		}
	}

	//returns true if the given arg is a number
	private boolean isNumeric(String num){
		try {
			Double.parseDouble(num);
			return true;
		} catch(NumberFormatException e){
			return false;
		}
	}

	//returns the precedence value of operators/functions, max=5 min=1
	private int precedence(String op){
		if(isUnaryOperator(op))
			return 5;
		if(op.equalsIgnoreCase("log") || op.equalsIgnoreCase("sin") || op.equalsIgnoreCase("tan") ||
				op.equalsIgnoreCase("cos") || op.equalsIgnoreCase("ln")
				|| op.equalsIgnoreCase("asin") || op.equalsIgnoreCase("atan") ||
				op.equalsIgnoreCase("acos") )
			return 4;
		if(op.equals("*") || op.equals("/") || op.equals("%"))
			return 3;
		if(op.equals("+") || op.equals("-"))
			return 2;
		
		return 1;
	}
}










